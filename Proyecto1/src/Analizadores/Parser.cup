/* SINTACTICO */

/* 1. package o importaciones */
package Analizadores;
import java_cup.runtime.*;
import java.util.stream.Collectors;
import java.util.ArrayList;
import java.util.List;
import java.util.LinkedList;
import Errores.Excepcion;

import abstracto.*;
import simbolo.*;

//=========INSTRUCCIONES=========
import instrucciones.*;

//=========EXPRESIONES=========
import expresiones.*;



/* 2. código para el parser, variables, métodos */
// PARSER
parser code
{:   

    //clases, objetos, variables, listas, etc.


    // salida consola
    public List<String> salidas = new ArrayList<String>();

    // errores
    public ArrayList<Excepcion> Errores = new ArrayList();

    // Método al que se llama automáticamente ante algún error sintáctico.
    public void syntax_error(Symbol s){ 
        Errores.add(new Excepcion("Sintáctico", "Error de sintaxis detectado. Se detectó: " + s.value, s.left, s.right));
        } 

    // Método al que se llama automáticamente ante algún error sintáctico, en el que ya no es posible una recuperación de errores.
    public void unrecovered_syntax_error(Symbol s) throws java.lang.Exception{ 
        System.out.println("Error sintactico irrecuperable en la Linea " + (s.left)+ " Columna "+s.right+". Componente " + s.value + " no reconocido."); 
    }

    public ArrayList<Excepcion> getErrores(){
        return Errores;
    }

    //========================



:}

/* 3. terminales */
terminal String PT_COMA, DOS_PT, PAR_IZQ, PAR_DER, LLAV_DER, LLAV_IZQ, PUNTO, COMA, COR_IZQ, COR_DER, ASIGNACION;
terminal String AND, OR, NOT, XOR;
terminal String MAS, MENOS, POR, DIV, MOD, POTENCIA, UMENOS, INC, DEC;
terminal String DISTINTO, IGUAL, IGUALIGUAL, MAYOR, MENOR, MAYORIGUAL, MENORIGUAL;
terminal String ENTERO, DECIMAL, ID,  BOOLEANO;
terminal String CARACTER, CADENA;

terminal String INT;
terminal String DOUBLE;
terminal String STRING;
terminal String CHAR;
terminal String BOOL;
terminal String TRUE, FALSE;

terminal String VAR;
terminal String CONST;

terminal String IF;
terminal String ELSE;
terminal String ELSEIF;

terminal String MATCH;
terminal String WHILE;
terminal String FOR;
terminal String DO;
terminal String BREAK;
terminal String CONTINUE;
terminal String RETURN;

terminal String CASE;
terminal String DEFAULT;

terminal String LIST;
terminal String NEW;
terminal String APPEND;
terminal String REMOVE;

terminal String STRUCT;

terminal String VOID;
terminal String PRINTLN;

terminal String ROUND;
terminal String LENGTH;
terminal String TOSTRING;
terminal String FIND;

terminal String START_WITH;

/* 4. No terminales */
non terminal LinkedList<Instruccion> ini, instrucciones;
non terminal Instruccion instruccion;
non terminal Instruccion imprimir;
non terminal Instruccion expresion;
non terminal Tipo tipo_datos;
non terminal Instruccion declaracion_id;
non terminal Instruccion asignacion_id;

non terminal String sentencia_if;
non terminal String sentencia_match;
non terminal String entornos;
non terminal String cases_default;
non terminal String cases;
non terminal String case;
non terminal String default;
non terminal String sentencia_while;
non terminal Instruccion sentencia_for;
non terminal String sentencia_do_while;
non terminal String entorno;
non terminal String mutabilidad;
non terminal Instruccion aritmeticos;
non terminal Instruccion relacionales;
non terminal Instruccion logicos;
non terminal String casteo;
non terminal Instruccion inc_dec;

/* 5. precedencias operadores */
precedence left OR;
precedence left AND;
precedence left XOR;
precedence left NOT;
precedence left IGUALIGUAL, DISTINTO, MENOR, MENORIGUAL, MAYOR, MAYORIGUAL;
precedence left MAS, MENOS;
precedence left POR, DIV, MOD;
precedence left POTENCIA;
precedence left UMENOS;


/* 6. Reglas de producción para expresiones */
start with ini;

ini ::= instrucciones:a                             {: RESULT = a; :}
;

instrucciones ::= instrucciones:a instruccion:b     {: RESULT = a; RESULT.add(b); :}
            | instruccion:a                         {: RESULT = new LinkedList<>(); RESULT.add(a); :}
;

instruccion ::= declaracion_id:a PT_COMA            {: RESULT = a; :}
                | asignacion_id:a PT_COMA           {: RESULT = a; :}         
                | sentencia_if
                | sentencia_match
                | sentencia_while
                | sentencia_for:a                   {: RESULT = a; :} 
                | sentencia_do_while
                | inc_dec:a PT_COMA                  {: RESULT = a; :}
                | imprimir:a                         {: RESULT = a; :}
                | RETURN expresion PT_COMA
                | RETURN PT_COMA
                | CONTINUE PT_COMA
                | BREAK PT_COMA
                | error
;

// ===== DECLARACION =====
declaracion_id ::= mutabilidad:a ID:b DOS_PT tipo_datos:c IGUAL expresion:d  {: RESULT = new Declaracion(a,b,c,d,aleft, aright); :}
                    | mutabilidad:a ID:b DOS_PT tipo_datos:c                 {: RESULT = new Declaracion(a,b,c,aleft, aright); :}
;

mutabilidad ::= VAR                 {: RESULT = "true"; :}
                | CONST             {: RESULT = "false"; :}
;

// ===== ASIGNACION =====
asignacion_id ::= ID:a IGUAL expresion:b        {: RESULT = new AsignacionVariables(a,b,aleft, aright); :}
;

// ===== SENTENCIAS DE CONTROL =====
// ===== SENTENCIA IF =====
sentencia_if ::= IF PAR_IZQ expresion PAR_DER entorno ELSE sentencia_if
                | IF PAR_IZQ expresion PAR_DER entorno ELSE entorno
                | IF PAR_IZQ expresion PAR_DER entorno
;

// ===== SENTENCIA MATCH =====
sentencia_match ::= MATCH expresion entornos ;

entornos ::= LLAV_IZQ cases_default LLAV_DER
            | LLAV_IZQ LLAV_DER
;

cases_default ::= cases default
                | cases
                | default
;

cases ::= cases case
        | case
;

case ::= expresion CASE entorno
;

default ::= DEFAULT CASE entorno
;

// ===== SENTENCIAS CICLICAS =====
// ===== SENTENCIA WHILE =====
sentencia_while ::= WHILE PAR_IZQ expresion PAR_DER entorno
;

// ===== SENTENCIA FOR =====
sentencia_for ::= FOR PAR_IZQ asignacion_id:a PT_COMA expresion:b PT_COMA inc_dec:c PAR_DER LLAV_IZQ instrucciones:d LLAV_DER {: RESULT = new For(a,b,c,d,aleft,aright); :}
;

// ===== SENTENCIA DO WHILE =====
sentencia_do_while ::= DO entorno WHILE PAR_IZQ expresion PAR_DER
;

// ===== PRINT =====
imprimir ::=  PRINTLN PAR_IZQ expresion:a PAR_DER PT_COMA     {: RESULT = new Print(a,aleft, aright); :}
;

// ===== EXPRESIONES =====
expresion ::= aritmeticos:a                {: RESULT = a; :}        
            | relacionales:a               {: RESULT = a; :}
            | logicos:a                    {: RESULT = a; :}
            | casteo    
            | ID        :a                 {: RESULT = new AccesoVariables(a,aleft, aright); :}
            | ENTERO    :a                 {: RESULT = new Nativo(Integer.parseInt(a), new Tipo(tipoDato.ENTERO),aleft, aright  ); :}
            | DECIMAL   :a                 {: RESULT = new Nativo(Double.parseDouble(a), new Tipo(tipoDato.DECIMAL),aleft, aright  ); :}
            | TRUE      :a                 {: RESULT = new Nativo(true, new Tipo(tipoDato.BOOLEANO),aleft, aright  ); :}
            | FALSE     :a                 {: RESULT = new Nativo(false, new Tipo(tipoDato.BOOLEANO),aleft, aright  ); :}    
            | CADENA    :a                 {: RESULT = new Nativo(a, new Tipo(tipoDato.CADENA),aleft, aright  ); :}
            | CARACTER  :a                 {: RESULT = new Nativo(a, new Tipo(tipoDato.CARACTER),aleft, aright  ); :}
            | PAR_IZQ expresion:a PAR_DER  {: RESULT = a; :}
;

aritmeticos ::=   expresion:a MAS expresion:b         {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.SUMA,aleft, aright); :}
                | expresion:a MENOS expresion:b       {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.RESTA,aleft, aright); :}
                | expresion:a POR expresion:b         {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.MULTIPLICACION,aleft, aright); :}
                | expresion:a DIV expresion:b         {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.DIVISION,aleft, aright); :}
                | expresion:a MOD expresion:b         {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.MODULO,aleft, aright); :}
                | expresion:a POTENCIA expresion:b    {: RESULT = new Aritmeticas(a,b , OperadoresAritmeticos.POTENCIA,aleft, aright); :}
                | MENOS expresion:a                   {: RESULT = new Aritmeticas(a   , OperadoresAritmeticos.NEGACION,aleft, aright); :}   %prec UMENOS 
;

relacionales ::= expresion:a IGUALIGUAL expresion:b   {: RESULT = new Relacionales(a,b , OperadoresRelacionales.EQUALS,aleft, aright); :}    %prec IGUALIGUAL
                | expresion:a DISTINTO expresion:b    {: RESULT = new Relacionales(a,b , OperadoresRelacionales.NOT_EQUALS,aleft, aright); :}
                | expresion:a MAYOR expresion:b       {: RESULT = new Relacionales(a,b , OperadoresRelacionales.GREATER_THAN,aleft, aright); :}
                | expresion:a MENOR expresion:b       {: RESULT = new Relacionales(a,b , OperadoresRelacionales.LESS_THAN,aleft, aright); :}
                | expresion:a MAYORIGUAL expresion:b  {: RESULT = new Relacionales(a,b , OperadoresRelacionales.GREATER_THAN_OR_EQUALS,aleft, aright); :}
                | expresion:a MENORIGUAL expresion:b  {: RESULT = new Relacionales(a,b , OperadoresRelacionales.LESS_THAN_OR_EQUALS,aleft, aright); :}
;

logicos ::= expresion:a OR expresion:b                 {: RESULT = new Logicos(a, OperadoresLogicos.OR, b,aleft, aright); :}
            | expresion:a AND expresion:b              {: RESULT = new Logicos(a, OperadoresLogicos.AND, b,aleft, aright); :}
            | expresion:a XOR expresion:b              {: RESULT = new Logicos(a, OperadoresLogicos.XOR, b,aleft, aright); :}
            | NOT expresion:a                          {: RESULT = new Logicos(   OperadoresLogicos.NOT, a,aleft, aright); :}                     
;

// ===== CASTEOS =====
casteo ::= PAR_IZQ tipo_datos PAR_DER expresion 
;

// ===== INCREMENTO/DECREMENTO =====
inc_dec ::= ID   :a INC :b   {: RESULT = new IncDec(a, b, aleft, aright); :}
            | ID :a DEC :b {: RESULT = new IncDec(a, b, aleft, aright); :}
;

// ===== TIPOS DE DATOS =====
tipo_datos ::= INT   :a     {: RESULT = new Tipo(tipoDato.ENTERO);   :}
            | DOUBLE :a     {: RESULT = new Tipo(tipoDato.DECIMAL);  :}
            | BOOL   :a     {: RESULT = new Tipo(tipoDato.BOOLEANO); :}
            | STRING :a     {: RESULT = new Tipo(tipoDato.CADENA);   :}
            | CHAR   :a     {: RESULT = new Tipo(tipoDato.CARACTER); :}
;